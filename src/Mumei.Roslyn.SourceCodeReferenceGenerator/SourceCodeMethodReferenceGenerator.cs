using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;


namespace Mumei.Roslyn.SourceCodeReferenceGenerator;

[Generator]
public class SourceCodeMethodReferenceGenerator : IIncrementalGenerator {
    private const string SourceCodeFactoryMetadataName = "SourceCodeFactory.SourceCode";
    private const string TemplateFragmentMetadataName = "SourceCodeFactory.TemplateFragment";

    private const string SourceFactoryCode =
        """
        // <auto-generated/>

        namespace SourceCodeFactory; 

        internal static class TemplateFragment {
            public static T For<T>(string name) {
                throw new global::System.NotSupportedException();
            }
        }

        internal sealed class MethodDeclarationRef {
            public string Declaration { get; set; }
            public string Name { get; set; } 
        }

        internal static partial class SourceCode {
          public static MethodDeclarationRef OfMethod<TContainingType>(string methodName) {
              throw new global::System.NotSupportedException();
          }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "SourceCode.Factory.Methods.g.cs",
            SourceText.From(SourceFactoryCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is InvocationExpressionSyntax {
                    Expression: MemberAccessExpressionSyntax {
                        Name.Identifier.ValueText: "OfMethod", Expression: IdentifierNameSyntax { Identifier.Text: "SourceCode" }
                    }
                },
                (ctx, _) => {
                    var sourceCodeFactory = ctx.SemanticModel.Compilation.GetTypeByMetadataName(SourceCodeFactoryMetadataName);
                    var calledMethod = ctx.SemanticModel.GetSymbolInfo(ctx.Node).Symbol as IMethodSymbol;
                    var areEqual = SymbolEqualityComparer.Default.Equals(calledMethod?.ContainingType, sourceCodeFactory);
                    if (calledMethod is null || ctx.Node is not InvocationExpressionSyntax invocation || !areEqual) {
                        return (false, null!, null!);
                    }

                    var containingType = calledMethod.TypeArguments[0];
                    var methodName = ctx.SemanticModel.GetConstantValue(invocation.ArgumentList.Arguments[0].Expression);
                    if (!methodName.HasValue) {
                        return (false, null!, null!);
                    }

                    var method = containingType.GetMembers(methodName.Value!.ToString()).OfType<IMethodSymbol>().FirstOrDefault();
                    return ((bool IsMatch, InvocationExpressionSyntax Invocation, IMethodSymbol Method))(true, invocation, method);
                })
            .Where(t => t.IsMatch)
            .Select((t, _) => (t.Invocation, t.Method));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right)
        );
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<(InvocationExpressionSyntax Invocation, IMethodSymbol MethodToGenerate)> refs
    ) {
        var interceptorClass = ClassDeclaration("SourceCodeFactory_GenerateMethod_Interceptor")
            .WithModifiers(TokenList(Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.StaticKeyword)));

        var templateFragmentType = compilation.GetTypeByMetadataName(TemplateFragmentMetadataName);

        foreach (var r in refs) {
            AddInterceptorCallForMethod(
                ref interceptorClass,
                compilation,
                r.MethodToGenerate,
                r.Invocation,
                templateFragmentType!
            );
        }

        var interceptorAttribute = ParseCompilationUnit(
            """
            #pragma warning disable
            namespace System.Runtime.CompilerServices {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file sealed class InterceptsLocationAttribute(int version, string data) : Attribute;
            }
            #pragma warning enable
            """).Members.First();

        var cu = CompilationUnit()
            .WithMembers(List((MemberDeclarationSyntax[]) [
                NamespaceDeclaration(ParseName(compilation.AssemblyName + ".Generated"))
                    .WithMembers(List<MemberDeclarationSyntax>([interceptorClass])),
                interceptorAttribute
            ]));

        context.AddSource("SourceCodeFactory.Interceptor.Methods.g.cs", cu.NormalizeWhitespace().ToFullString());
    }

    private static void AddInterceptorCallForMethod(ref ClassDeclarationSyntax interceptorClass,
        Compilation compilation,
        IMethodSymbol methodToGenerate,
        InvocationExpressionSyntax invocation,
        INamedTypeSymbol templateFragmentType
    ) {
        var interceptMethod = MethodDeclaration(
                ParseTypeName("global::SourceCodeFactory.MethodDeclarationRef"),
                $"Intercept_MethodDeclarationOf__{Guid.NewGuid():N}"
            )
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)))
            .WithTypeParameterList(TypeParameterList(SeparatedList([TypeParameter("T")])))
            .WithParameterList(ParameterList(SeparatedList([
                Parameter(Identifier("methodName"))
                    .WithType(ParseTypeName("string"))
            ])));

        var body = Block(
            ReturnStatement(
                InstantiateSourceCodeTypeRef(compilation, methodToGenerate, templateFragmentType)
            )
        );

        if (compilation.GetSemanticModel(invocation.SyntaxTree).GetInterceptableLocation(invocation) is not { } location) {
            throw new InvalidOperationException($"Could not intercept {invocation} in {invocation.SyntaxTree.FilePath}");
        }

        interceptMethod = interceptMethod.WithBody(body)
            .WithAttributeLists(
                List([
                    AttributeList(SeparatedList([
                        Attribute(
                            ParseName("System.Runtime.CompilerServices.InterceptsLocation"),
                            AttributeArgumentList(SeparatedList([
                                AttributeArgument(
                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(location.Version))
                                ),
                                AttributeArgument(
                                    LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(location.Data))
                                )
                            ]))
                        )
                    ]))
                ])
            );

        interceptorClass = interceptorClass.AddMembers(interceptMethod);
    }

    private static ObjectCreationExpressionSyntax InstantiateSourceCodeTypeRef(
        Compilation compilation,
        IMethodSymbol targetMethod,
        INamedTypeSymbol templateFragmentType
    ) {
        if (targetMethod.DeclaringSyntaxReferences.First().GetSyntax() is not MemberDeclarationSyntax templateNode) {
            throw new InvalidOperationException("Type does not have a declaration");
        }

        var globalized = TemplateRewriter.TransformToTemplate(
            compilation.GetSemanticModel(templateNode.SyntaxTree),
            templateNode,
            templateFragmentType
        );

        var sourceCode = globalized.NormalizeWhitespace().ToFullString();

        return ObjectCreationExpression(ParseTypeName("global::SourceCodeFactory.MethodDeclarationRef"))
            .WithInitializer(InitializerExpression(SyntaxKind.ObjectInitializerExpression,
                SeparatedList(new ExpressionSyntax[] {
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("Declaration"),
                        RawStringLiteral(sourceCode)
                    ),
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("Name"),
                        LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(targetMethod.Name))
                    )
                })
            ));
    }

    public static LiteralExpressionSyntax RawStringLiteral(string value) {
        return (LiteralExpressionSyntax)ParseExpression($""""""""""""""""
                                                         """"""""""""
                                                         {value}
                                                         """"""""""""
                                                         """""""""""""""");
    }

}