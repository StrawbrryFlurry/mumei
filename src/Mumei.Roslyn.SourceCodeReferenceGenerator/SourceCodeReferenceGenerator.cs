using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;


namespace Mumei.Roslyn.SourceCodeReferenceGenerator;

[Generator]
public class SourceCodeReferenceGenerator : IIncrementalGenerator {
    private const string SourceCodeFactoryMetadataName = "SourceCodeFactory.SourceCode";

    private const string SourceFactoryCode =
        """
        // <auto-generated/>

        namespace SourceCodeFactory; 

        internal sealed class SourceCodeTypeRef : global::Mumei.Roslyn.Testing.ICompilationReference {
          public string TypeName { get; init; }
          public string SourceCode { get; init; }
          public global::System.Collections.Immutable.ImmutableArray<global::Mumei.Roslyn.Testing.ICompilationReference> References { get; init; }

          public void AddToCompilation(System.Collections.Generic.List<Microsoft.CodeAnalysis.SyntaxTree> syntaxTreesRef, Mumei.Roslyn.Testing.MetadataReferenceCollection metadataRef) {
            AddToCompilationCore(syntaxTreesRef, metadataRef, new System.Collections.Generic.HashSet<string>());
          }
          
          private void AddToCompilationCore(System.Collections.Generic.List<Microsoft.CodeAnalysis.SyntaxTree> syntaxTreesRef, Mumei.Roslyn.Testing.MetadataReferenceCollection metadataRef, System.Collections.Generic.HashSet<string> seenTexts) {
            if (seenTexts.Add(TypeName)) {
              var syntaxTree = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(SourceCode, path: TypeName);
              syntaxTreesRef.Add(syntaxTree);
            }
            
            foreach (var reference in References) {
                if (reference is AssemblyTypeRef assemblyRef) {
                    metadataRef.AddReference(assemblyRef.AssemblyName);
                    continue;
                }
            
                if (reference is SourceCodeTypeRef sourceRef) {
                    sourceRef.AddToCompilationCore(syntaxTreesRef, metadataRef, seenTexts);
                }
            }
           }
        }

        internal sealed class AssemblyTypeRef : global::Mumei.Roslyn.Testing.ICompilationReference {
          public string AssemblyName { get; init; }
          public string FullyQualifiedName { get; init; }
          
          public void AddToCompilation(System.Collections.Generic.List<Microsoft.CodeAnalysis.SyntaxTree> syntaxTreesRef, Mumei.Roslyn.Testing.MetadataReferenceCollection metadataRef) {
            metadataRef.AddReference(AssemblyName);
          }
        }

        internal static partial class SourceCode {
          public static SourceCodeTypeRef Of<T>() {
              throw new global::System.NotImplementedException();
          }
          
          public static TSyntaxNode OfSyntax<TSyntaxNode>(
            global::System.Action code,
            Func<TSyntaxNode, bool>? predicate = null
          ) where TSyntaxNode : global::Microsoft.CodeAnalysis.SyntaxNode {
              throw new global::System.NotImplementedException();
          }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "SourceCode.Factory.g.cs",
            SourceText.From(SourceFactoryCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is InvocationExpressionSyntax {
                    Expression: MemberAccessExpressionSyntax {
                        Name.Identifier.ValueText: "Of" or "OfSyntax", Expression: IdentifierNameSyntax { Identifier.Text: "SourceCode" }
                    }
                },
                (ctx, _) => {
                    var sourceCodeFactory = ctx.SemanticModel.Compilation.GetTypeByMetadataName(SourceCodeFactoryMetadataName);
                    var calledMethod = ctx.SemanticModel.GetSymbolInfo(ctx.Node).Symbol as IMethodSymbol;
                    var areEqual = SymbolEqualityComparer.Default.Equals(calledMethod?.ContainingType, sourceCodeFactory);
                    if (calledMethod is null || ctx.Node is not InvocationExpressionSyntax invocation || !areEqual) {
                        return (false, null!, null!);
                    }

                    var typeArgument = calledMethod.TypeArguments[0];
                    return ((bool IsMatch, InvocationExpressionSyntax Invocation, INamedTypeSymbol SourceType)) (true, invocation, typeArgument);
                })
            .Where(t => t.IsMatch)
            .Select((t, _) => (t.Invocation, t.SourceType));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right)
        );
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<(InvocationExpressionSyntax Invocation, INamedTypeSymbol RefType)> refs
    ) {
        var interceptorClass = ClassDeclaration("SourceCodeFactory_Interceptor")
            .WithModifiers(TokenList(Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.StaticKeyword)));

        foreach (var r in refs) {
            AddInterceptorCallForMethod(ref interceptorClass, compilation, r.RefType, r.Invocation);
        }

        var interceptorAttribute = ParseCompilationUnit(
            """
            #pragma warning disable
            namespace System.Runtime.CompilerServices {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file sealed class InterceptsLocationAttribute(int version, string data) : Attribute;
            }
            #pragma warning enable
            """).Members.First();

        var cu = CompilationUnit()
            .WithMembers(List((MemberDeclarationSyntax[]) [
                NamespaceDeclaration(ParseName(compilation.AssemblyName + ".Generated"))
                    .WithMembers(List<MemberDeclarationSyntax>([interceptorClass])),
                interceptorAttribute
            ]));

        context.AddSource("SourceCodeFactory.interceptor.g.cs", cu.NormalizeWhitespace().ToFullString());
    }

    private static void AddInterceptorCallForMethod(
        ref ClassDeclarationSyntax interceptorClass,
        Compilation compilation,
        INamedTypeSymbol targetType,
        InvocationExpressionSyntax invocation
    ) {
        var interceptMethod = MethodDeclaration(ParseTypeName("global::SourceCodeFactory.SourceCodeTypeRef"), $"Intercept_SourceCodeOf__{Guid.NewGuid():N}")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)))
            .WithTypeParameterList(TypeParameterList(SeparatedList([TypeParameter("T")])));

        var body = Block(
            ReturnStatement(
                InstantiateSourceCodeTypeRef(compilation, targetType)
            )
        );

        var sm = compilation.GetSemanticModel(invocation.SyntaxTree);
        var location = sm.GetInterceptableLocation(invocation);

        interceptMethod = interceptMethod.WithBody(body)
            .WithAttributeLists(
                List([
                    AttributeList(SeparatedList([
                        Attribute(
                            ParseName("System.Runtime.CompilerServices.InterceptsLocation"),
                            AttributeArgumentList(SeparatedList([
                                AttributeArgument(
                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(location!.Version))
                                ),
                                AttributeArgument(
                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(location.Data))
                                )
                            ]))
                        )
                    ]))
                ])
            );

        interceptorClass = interceptorClass.AddMembers(interceptMethod);
    }

    private static ObjectCreationExpressionSyntax InstantiateSourceCodeTypeRef(
        Compilation compilation,
        ITypeSymbol targetType,
        HashSet<ITypeSymbol>? processedTypes = null
    ) {
        processedTypes ??= new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);

        if (targetType.DeclaringSyntaxReferences.First().GetSyntax() is not MemberDeclarationSyntax refNode) {
            throw new InvalidOperationException("Type does not have a declaration");
        }

        var (typeReferences, aliases) = TypeUsageTracker.FindUsedTypes(
            compilation.GetSemanticModel(refNode.SyntaxTree),
            refNode
        );

        var usingDirectives = typeReferences
            .Distinct(SymbolEqualityComparer.Default)
            .Where(x => x.ContainingNamespace is not null && !SymbolEqualityComparer.Default.Equals(x.ContainingNamespace, targetType.ContainingNamespace)) // Skip our own namespace
            .Select(t => t!.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
            .Where(x => !targetType.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .StartsWith(x)) // Skip namespaces we're implicitly part of
            .Distinct()
            .Select(x => UsingDirective(ParseName(x)))
            .ToList();

        foreach (var alias in aliases.Distinct(SymbolEqualityComparer.Default).OfType<IAliasSymbol>()) {
            usingDirectives.Add(
                UsingDirective(
                    NameEquals(alias.Name),
                    ParseTypeName(alias.Target.Name) // Later we prolly want to spit out all types into their original namespace
                )
            );
        }

        var sourceCodeNode = refNode;
        if (refNode is ClassDeclarationSyntax classDecl) {
            if (classDecl.Modifiers.Any(SyntaxKind.FileKeyword)) {
                sourceCodeNode = classDecl.WithModifiers(
                    TokenList(classDecl.Modifiers.Where(x => !x.IsKind(SyntaxKind.FileKeyword)))
                );
            }

            if (classDecl.Modifiers.Any(SyntaxKind.PrivateKeyword)) {
                sourceCodeNode = classDecl.WithModifiers(
                    TokenList(classDecl.Modifiers.Where(x => !x.IsKind(SyntaxKind.PrivateKeyword)))
                );
            }

            var strippedDuplicateMembersAlreadyCoveredByImportedTypes =
                classDecl.Members.Where(x => x is not ClassDeclarationSyntax cls || typeReferences.Any(t => t.Name == cls.Identifier.Text));
            sourceCodeNode = ((ClassDeclarationSyntax) sourceCodeNode).WithMembers(List(strippedDuplicateMembersAlreadyCoveredByImportedTypes));
        }

        var compilationUnitWithUsings = CompilationUnit()
            .WithUsings(List(usingDirectives))
            .AddMembers(MakeQualifiedCompilationUnitMember(targetType, sourceCodeNode));

        var sourceCode = compilationUnitWithUsings.NormalizeWhitespace().ToFullString();
        var references = MakeSourceTypeReferencesArray(compilation, typeReferences, processedTypes);

        return ObjectCreationExpression(ParseTypeName("global::SourceCodeFactory.SourceCodeTypeRef"))
            .WithInitializer(InitializerExpression(SyntaxKind.ObjectInitializerExpression,
                SeparatedList(new ExpressionSyntax[] {
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("TypeName"),
                        LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(targetType.Name))
                    ),
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("SourceCode"),
                        RawStringLiteral(sourceCode)
                    ),
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("References"),
                        references
                    )
                })
            ));
    }

    private static MemberDeclarationSyntax MakeQualifiedCompilationUnitMember(ITypeSymbol type, MemberDeclarationSyntax member) {
        if (type.ContainingNamespace.IsGlobalNamespace) {
            return member;
        }

        var ns = type.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Substring("global::".Length);
        return NamespaceDeclaration(ParseName(ns)).WithMembers([member]);
    }

    private static ExpressionSyntax MakeSourceTypeReferencesArray(
        Compilation compilation,
        ImmutableArray<ITypeSymbol> typeReferences,
        HashSet<ITypeSymbol> processedTypes
    ) {
        var references = InvocationExpression(
            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                ParseTypeName("global::System.Collections.Immutable.ImmutableArray"),
                GenericName("Create").WithTypeArgumentList(TypeArgumentList(SeparatedList([ParseTypeName("global::Mumei.Roslyn.Testing.ICompilationReference")])))
            )
        );

        if (typeReferences.Length == 0) {
            return references;
        }

        var elements = new List<ExpressionSyntax>();
        foreach (var type in typeReferences) {
            if (!processedTypes.Add(type)) {
                continue;
            }

            if (type is ITypeParameterSymbol) {
                continue;
            }

            if (type.DeclaringSyntaxReferences.IsEmpty) {
                if (type.ContainingAssembly is null) {
                    continue;
                }

                elements.Add(
                    ObjectCreationExpression(ParseTypeName("global::SourceCodeFactory.AssemblyTypeRef"))
                        .WithInitializer(InitializerExpression(SyntaxKind.ObjectInitializerExpression,
                            SeparatedList(new ExpressionSyntax[] {
                                AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("AssemblyName"),
                                    LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(type.ContainingAssembly.Name))
                                ),
                                AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("FullyQualifiedName"),
                                    LiteralExpression(SyntaxKind.StringLiteralExpression,
                                        Literal(type.ToDisplayString(NullableFlowState.NotNull, SymbolDisplayFormat.FullyQualifiedFormat))
                                    )
                                )
                            })
                        ))
                );

                continue;
            }

            // elements.Add(InstantiateSourceCodeTypeRef(compilation, type, processedTypes));
        }

        return references.WithArgumentList(ArgumentList(SeparatedList(
            elements.Select(Argument)
        )));
    }

    public static LiteralExpressionSyntax RawStringLiteral(string value) {
        return (LiteralExpressionSyntax) ParseExpression($""""""""""""""""
                                                          """"""""""""
                                                          {value}
                                                          """"""""""""
                                                          """""""""""""""");
    }

}