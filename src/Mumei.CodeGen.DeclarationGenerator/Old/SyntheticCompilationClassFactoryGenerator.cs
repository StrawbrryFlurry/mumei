using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Mumei.CodeGen.Components;
using Mumei.CodeGen.Rendering;
using Mumei.CodeGen.Rendering.CSharp;
using Mumei.CodeGen.Roslyn.Components;

namespace Mumei.CodeGen.DeclarationGenerator;

public sealed class SyntheticCompilationClassFactoryGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) { }

    private static void DeclareInterceptorMethod(
        ISyntheticClassBuilder<CompileTimeUnknown> classBuilder,
        ITypeSymbol classDecl,
        InvocationExpressionSyntax invocationExpressionSyntax
    ) {
        // var binderClass = classBuilder.DeclareNestedClass<SyntheticClassDynamicMemberBinder<CompileTimeUnknown>>(
        //     $"DeclareClass__MemberBinder_{classDecl.Name}",
        //     binder => {
        //         binder.DefinitionClass = classDecl;
        //     }
        // ).WithAccessibility(AccessModifier.Private + AccessModifier.Sealed);

        var interceptMethod = classBuilder.DeclareInterceptorMethod(
            classBuilder.MakeUniqueName($"Intercept_DeclareClass__{classDecl.Name}}}"),
            invocationExpressionSyntax
        ).WithAccessibility(AccessModifier.Private + AccessModifier.Static);

        interceptMethod.WithBody(new QtSyntheticRenderCodeBlock(renderTree => {
            renderTree.Line("");
        }));
    }
}

// This is what we generate for all synthetic class definitions,
// containing the dynamic members bound in SetupDynamic as well as any members declared as outputs.
// We also use this as a container for generating all the method implementations
[CompilerGenerated]
file sealed partial class SyntheticClassDynamicMemberBinder<TClassDefinition> {
    public override void InternalBindCompilerOutputMembers(ISyntheticClassBuilder<SyntheticClassDynamicMemberBinder<TClassDefinition>> classBuilder) {
        // classBuilder.λCompilerApi.BindMethodSlot();
        classBuilder.ΦCompilerApi.DeclareMethod(
            [],
            AccessModifier.Public,
            new RuntimeSyntheticType(typeof(void)),
            "BindCompilerOutputMembers",
            [],
            [],
            new SyntheticClassDynamicMemberBinder__MethodDeclaration_BindCompilerOutputMembers__0(this)
        );
    }

    private sealed class SyntheticClassDynamicMemberBinder__MethodDeclaration_BindCompilerOutputMembers__0(
        SyntheticClassDynamicMemberBinder<TClassDefinition> input
    ) : ISyntheticCodeBlock, ISyntheticConstructable<CodeBlockFragment> {
        public CodeBlockFragment Construct(ICompilationUnitContext compilation) {
            return CodeBlockFragment.Create(RenderBody);
        }

        private void RenderBody(IRenderTreeBuilder renderTree) {
            // Literally transforming CompileTimeForEach to a normal foreach
            // might make the most sense?
            foreach (var bindOutputMethod in input._outputBinderMethods) {
                var methodMacro = Unsafe.As<SyntheticMethodInfo_MacroBinderImpl>(bindOutputMethod);
                renderTree.Text(methodMacro.Bind__Bind(null!));
                renderTree.Text(methodMacro.Bind__Invoke(null!));
            }
        }

        private sealed class SyntheticMethodInfo_MacroBinderImpl {
            public string Bind__Invoke(dynamic callsite) {
                // take arguments from callsite
                // take method name from self
                return "BindOutput__field__someField(classBuilder)";
            }

            public string Bind__Bind(dynamic callsite) {
                // if callsite is this
                return "this.";
            }
        }
    }


    // This should be generated by the method body interceptor
    private sealed class SyntheticClassDynamicMemberBinder__MethodDeclaration_DeclareBindOutputField__0(
        SyntheticClassDynamicMemberBinder__MethodDeclaration_DeclareBindOutputField__0.Inputs inputs
    ) : ISyntheticCodeBlock, ISyntheticConstructable<CodeBlockFragment> {
        public CodeBlockFragment Construct(ICompilationUnitContext compilation) {
            return CodeBlockFragment.Create(RenderBody);
        }

        private void RenderBody(IRenderTreeBuilder renderTree) {
            renderTree.Text("defBuilder.DeclareField(");
            renderTree.Text("typeof(");
            // Something like a type or type symbol is obvious to serialize
            // For more complex types we need to know what to do here - See macros
            // We should prolly use the same mechanism as the compiler does for resolving user defined
            // enumerables and awaitables. E.g. expose the macro for rendering the type symbol as an extension method?
            renderTree.Text(TypeSymbolMacroExtensions.Bind__self(inputs.Field.Type, null!));
            renderTree.Text(", ");
            renderTree.Text(inputs.Field.Name);
            renderTree.Text(");");
        }

        public static class TypeSymbolMacroExtensions {
            public static string Bind__self(ITypeSymbol typeSymbol, dynamic callsite) {
                return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
        }

        public readonly record struct Inputs(IFieldSymbol Field);
    }
}

file sealed partial class SyntheticClassDynamicMemberBinder<[Bindable] TClassDefinition> : SyntheticClassDefinition<SyntheticClassDynamicMemberBinder<TClassDefinition>> {
    [Input]
    public ITypeSymbol DefinitionClass { get; set; }


    private readonly List<ISyntheticMethod<Action<ISyntheticClassBuilder<TClassDefinition>>>> _outputBinderMethods;

    public override void Setup(ISyntheticClassBuilder<SyntheticClassDynamicMemberBinder<TClassDefinition>> classBuilder) {
        // classBuilder.Bind<SyntheticClassDynamicMemberBinder<TClassDefinition>, TClassDefinition>(DefinitionClass);

        // var outputAttribute = Compilation.TypeFromCompilation<OutputAttribute>();
        var outputMembers = DefinitionClass.GetMembers().Where(x => x.GetAttributes().Any(a => a.AttributeClass?.Equals(null!, SymbolEqualityComparer.Default) ?? false));

        foreach (var outputMember in outputMembers) {
            if (outputMember is IFieldSymbol outputField) {
                DeclareBindOutputField(classBuilder, outputField);
            }

            if (outputMember is IPropertySymbol outputProperty) {
                DeclareBindOutputProperty(classBuilder, outputProperty);
            }

            if (outputMember is IMethodSymbol outputMethod) {
                DeclareBindOutputMethod(classBuilder, outputMethod);
            }
        }
    }

    private void DeclareBindOutputField(ISyntheticClassBuilder<SyntheticClassDynamicMemberBinder<TClassDefinition>> classBuilder, IFieldSymbol field) {
        var bindMethod = classBuilder.DeclareMethod<Action<ISyntheticClassBuilder<TClassDefinition>>>($"BindOutput__field_{field.Name}");
        bindMethod.WithBody(new { Field = field }, static state => defBuilder => {
            defBuilder.DeclareField(state.Field.Type, state.Field.Name);
        });
        _outputBinderMethods.Add(bindMethod);
    }

    private void DeclareBindOutputProperty(ISyntheticClassBuilder<SyntheticClassDynamicMemberBinder<TClassDefinition>> classBuilder, IPropertySymbol property) {
        var bindMethod = classBuilder.DeclareMethod<Action<ISyntheticClassBuilder<TClassDefinition>>>($"BindOutput__property_{property.Name}");
        bindMethod.WithBody(new { Property = property }, static state => defBuilder => {
            defBuilder.DeclareProperty(state.Property.Type, state.Property.Name);
            // Handle getters and setters if needed
        });
        _outputBinderMethods.Add(bindMethod);
    }

    private void DeclareBindOutputMethod(ISyntheticClassBuilder<SyntheticClassDynamicMemberBinder<TClassDefinition>> classBuilder, IMethodSymbol method) {
        var bindMethod = classBuilder.DeclareMethod<Action<ISyntheticClassBuilder<TClassDefinition>>>($"BindOutput__method_{method.Name}");
        bindMethod.WithBody(new { Method = method }, static state => defBuilder => {
            defBuilder.DeclareMethod<Delegate>(state.Method.Name);
        });

        _outputBinderMethods.Add(bindMethod);
    }

    [Output(Name = nameof(SyntheticClassDefinition<>.InternalBindCompilerOutputMembers))]
    public void BindCompilerOutputMembers(ISyntheticClassBuilder<TClassDefinition> classBuilder) {
        foreach (var bindOutputMethod in CompileTimeForEach(_outputBinderMethods)) {
            bindOutputMethod.Bind(this)(classBuilder);
        }
    }
}

// Since we now generate the dynamic part of the class binder in a partial class we don't need to intercept the declare class method anymore.
file sealed partial class DeclareClassDefinitionMethod<[Bindable] TClassDefinition> : SyntheticInterceptorMethodDefinition where TClassDefinition : SyntheticClassDefinition<TClassDefinition>, new() {
    [Input]
    public ITypeSymbol ClassDefinitionType { get; set; }

    public override void BindDynamicComponents() {
        this.Bind(typeof(TClassDefinition), ClassDefinitionType);
    }

    public ISyntheticClassBuilder<TClassDefinition> InterceptDeclareClass(
        ISyntheticCodeBlock compilation,
        string name,
        Action<TClassDefinition> bindInputs
    ) {
        return null!;
    }
}