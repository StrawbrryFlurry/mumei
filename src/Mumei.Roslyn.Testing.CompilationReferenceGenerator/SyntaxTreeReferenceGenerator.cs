using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;
using Mumei.CodeGen;
using Mumei.CodeGen.Rendering;
using Mumei.CodeGen.Rendering.CSharp;
using Mumei.CodeGen.Roslyn.Components;
using Mumei.CodeGen.Roslyn.RoslynCodeProviders;

namespace Mumei.Roslyn.Testing.CompilationReferenceGenerator;

[Generator]
public sealed class SyntaxTreeReferenceGenerator : IIncrementalGenerator {
    private const string SyntaxTreeReferenceType = "SyntaxTreeReference";

    private const string SyntaxTreeReferenceCode =
        $$"""
          // <auto-generated/>
            
          namespace Mumei.Roslyn.Testing;
            
          [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
          internal static partial class {{SyntaxTreeReferenceType}} {
            public static global::Mumei.Roslyn.Testing.ICompilationReference Of<T>() {
                throw new global::System.InvalidOperationException("This method is intended to be intercepted at compile time and never invoked directly.");
            }
            
            public static global::Mumei.Roslyn.Testing.ICompilationReference Of(global::System.Type t) {
              throw new global::System.InvalidOperationException("This method is intended to be intercepted at compile time and never invoked directly.");
            }
          }

          [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
          internal sealed class RootCompilationReference : global::Mumei.Roslyn.Testing.ICompilationReference {
              public required global::System.Collections.Immutable.ImmutableArray<global::Mumei.Roslyn.Testing.ICompilationReference> References { get; init; }

              public void AddToCompilation(global::System.Collections.Generic.List<global::Microsoft.CodeAnalysis.SyntaxTree> syntaxTreesRef, global::Mumei.Roslyn.Testing.MetadataReferenceCollection metadataRef) {
                  foreach (var compilationReference in References) {
                      compilationReference.AddToCompilation(syntaxTreesRef, metadataRef);
                  }
              }
          }

          [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
          internal sealed class SyntaxTreeCompilationReference : global::Mumei.Roslyn.Testing.ICompilationReference {
              public required string TypeName { get; init; }
              public required string SourceCode { get; init; }
              public required global::System.Collections.Immutable.ImmutableArray<global::Mumei.Roslyn.Testing.ICompilationReference> References { get; init; }

              public void AddToCompilation(global::System.Collections.Generic.List<Microsoft.CodeAnalysis.SyntaxTree> syntaxTreesRef, global::Mumei.Roslyn.Testing.MetadataReferenceCollection metadataRef) {
                  AddToCompilationCore(syntaxTreesRef, metadataRef, new global::System.Collections.Generic.HashSet<string>());
              }

              private void AddToCompilationCore(global::System.Collections.Generic.List<Microsoft.CodeAnalysis.SyntaxTree> syntaxTreesRef, global::Mumei.Roslyn.Testing.MetadataReferenceCollection metadataRef, global::System.Collections.Generic.HashSet<string> seenTexts) {
                  if (seenTexts.Add(TypeName)) {
                      var syntaxTree = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(SourceCode, path: TypeName);
                      syntaxTreesRef.Add(syntaxTree);
                  }

                  foreach (var reference in References) {
                      if (reference is global::Mumei.Roslyn.Testing.AssemblyCompilationReference assemblyRef) {
                          assemblyRef.AddToCompilation(syntaxTreesRef, metadataRef);
                          continue;
                      }

                      if (reference is global::Mumei.Roslyn.Testing.SyntaxTreeCompilationReference sourceRef) {
                          sourceRef.AddToCompilationCore(syntaxTreesRef, metadataRef, seenTexts);
                      }
                  }
              }
          }

          [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
          internal sealed class AssemblyCompilationReference : global::Mumei.Roslyn.Testing.ICompilationReference {
              public required string AssemblyName { get; init; }
              public required string TypeName { get; init; }

              public void AddToCompilation(global::System.Collections.Generic.List<global::Microsoft.CodeAnalysis.SyntaxTree> syntaxTreesRef, global::Mumei.Roslyn.Testing.MetadataReferenceCollection metadataRef) {
                  metadataRef.AddReference(AssemblyName);
              }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(static ctx => {
            ctx.AddEmbeddedAttributeDefinition();
            ctx.AddSource("SyntaxTreeReference.g.cs", SourceText.From(SyntaxTreeReferenceCode, Encoding.UTF8));
        });

        var p = context.CreateQtProvider(
            (node, ct) => {
                return SyntaxNodeFilter.IsInvocationOf(node, "Of", SyntaxTreeReferenceType);
            },
            static (ctx, ct) => {
                var sourceCodeFactory = ctx.SemanticModel.Compilation.GetTypeByMetadataName($"Mumei.Roslyn.Testing.{SyntaxTreeReferenceType}");
                if (ctx.SemanticModel.GetOperation(ctx.Node) is not IInvocationOperation invocationOp) {
                    return default;
                }

                if (invocationOp.TargetMethod.TypeArguments.Length != 1 && invocationOp.Arguments.Length != 1) {
                    return default;
                }

                if (!SymbolEqualityComparer.Default.Equals(invocationOp.TargetMethod.ContainingType, sourceCodeFactory)) {
                    return default;
                }

                var targetType = invocationOp.TargetMethod.TypeArguments.Length == 1
                    ? invocationOp.TargetMethod.TypeArguments[0]
                    : invocationOp.Arguments[0].Value switch {
                        ITypeOfOperation typeOfOp => typeOfOp.TypeOperand,
                        _ => null
                    };
                return (IsMatch: true, InvocationNode: new SyntaxNodeEquatable<InvocationExpressionSyntax>((InvocationExpressionSyntax) ctx.Node), TargetType: new IgnoreEquality<ITypeSymbol?>(targetType), ctx.Node.GetLocation());
            }
        ).Where(x => x.Value.IsMatch);

        var o = p.IncrementalGenerate(static (ctx, expr, ct) => {
            // var interceptorNamespace = ctx.NamespaceFromAssemblyName("Interceptors");
            var interceptorNamespace = ctx.Namespace("Generated");

            var interceptor = interceptorNamespace.DeclareClass("SyntaxTreeReferenceInterceptor")
                .WithAccessibility(AccessModifier.Internal + AccessModifier.Partial + AccessModifier.Static);

            var syntaxTreeRef = CreateSyntaxTreeReferenceExpression(
                expr.TargetType!.Value,
                ctx.Compilation
            );

            interceptor.DeclareInterceptorMethod(
                    interceptor.MakeUniqueName("Intercept_Of"),
                    expr.InvocationNode.Node
                )
                .WithBody(ctx.Block(renderTree => {
                    renderTree.Interpolate($"return {syntaxTreeRef};");
                }));

            ctx.EmitIncremental("SyntaxTreeReferenceInterceptor", interceptor);
        });

        context.RegisterCodeGenerationOutput(o);
    }

    private static ExpressionFragment CreateSyntaxTreeReferenceExpression(
        ITypeSymbol targetType,
        Compilation compilation
    ) {
        if (targetType.DeclaringSyntaxReferences is not [var declarationReference]) {
            throw new InvalidOperationException("Unable to get syntax reference for type.");
        }

        if (declarationReference.GetSyntax() is not TypeDeclarationSyntax typeDeclarationSyntax) {
            throw new InvalidOperationException("Unable to get type declaration syntax.");
        }

        var renderTree = new SourceFileRenderTreeBuilder();

        renderTree.Line("new global::Mumei.Roslyn.Testing.RootCompilationReference {");
        renderTree.StartBlock();

        renderTree.Line("References = [");
        renderTree.StartBlock();

        foreach (var memberDeclarationSyntax in typeDeclarationSyntax.Members) {
            if (memberDeclarationSyntax is not TypeDeclarationSyntax typeToEmit) {
                continue;
            }

            var symbol = compilation.GetSemanticModel(typeDeclarationSyntax.SyntaxTree)
                .GetDeclaredSymbol(typeToEmit) ?? throw new InvalidOperationException("Unable to get type symbol from declaration within referenced type.");

            AppendSyntaxTreeCompilationReference(
                renderTree,
                typeToEmit,
                symbol,
                compilation
            );
        }

        renderTree.EndBlock();
        renderTree.Line("]");
        renderTree.EndBlock();
        renderTree.Text("}");

        return new ExpressionFragment(renderTree.ToString());
    }

    private static void AppendSyntaxTreeCompilationReference(
        IRenderTreeBuilder renderTree,
        TypeDeclarationSyntax typeReference,
        ITypeSymbol typeSymbol,
        Compilation compilation,
        HashSet<ITypeSymbol>? seenTypes = null!
    ) {
        seenTypes ??= new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);
        if (!seenTypes.Add(typeSymbol)) {
            return;
        }

        renderTree.Line("new global::Mumei.Roslyn.Testing.SyntaxTreeCompilationReference {");
        renderTree.StartBlock();

        var sm = compilation.GetSemanticModel(typeReference.SyntaxTree);
        var typeDeclarationsCoveredByThisType = typeReference.DescendantNodes(x => true)
            .Where(x => x is TypeDeclarationSyntax)
            .Cast<TypeDeclarationSyntax>();

        foreach (var innerTypeDeclarations in typeDeclarationsCoveredByThisType) {
            var symbol = sm.GetDeclaredSymbol(innerTypeDeclarations);
            seenTypes.Add(symbol!);
        }

        var (typeReferences, aliases) = TypeUsageTracker.FindUsedTypes(sm, typeReference);
        var thisTypeDeclarationSource = GetTypeDeclarationSyntaxTree(typeReference, typeSymbol, typeReferences, aliases);

        renderTree.InterpolatedLine($"TypeName = {typeReference.Identifier.Text:q},");
        renderTree.InterpolatedLine($"SourceCode = {thisTypeDeclarationSource},");
        renderTree.Line("References = [");

        renderTree.StartBlock();

        var assemblyReferences = new HashSet<IAssemblySymbol>(SymbolEqualityComparer.Default);
        foreach (var reference in typeReferences) {
            // Declared outside of this compilation
            if (reference.DeclaringSyntaxReferences is []) {
                if (!assemblyReferences.Add(reference.ContainingAssembly)) {
                    continue;
                }

                renderTree.Line("new global::Mumei.Roslyn.Testing.AssemblyCompilationReference {");
                renderTree.StartBlock();
                renderTree.InterpolatedLine($"TypeName = {reference.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat):q},");
                renderTree.InterpolatedLine($"AssemblyName = {reference.ContainingAssembly.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat):q},");
                renderTree.EndBlock();
                renderTree.Line("},");
            }

            if (reference.DeclaringSyntaxReferences is [var declaration]) {
                if (declaration.GetSyntax() is not TypeDeclarationSyntax referencedTypeDeclaration) {
                    continue;
                }

                AppendSyntaxTreeCompilationReference(
                    renderTree,
                    referencedTypeDeclaration,
                    reference,
                    compilation,
                    seenTypes
                );
            }
        }

        renderTree.EndBlock();
        renderTree.Line("]");
        renderTree.EndBlock();
        renderTree.Line("},");
    }

    private static RawStringLiteralFragment GetTypeDeclarationSyntaxTree(
        TypeDeclarationSyntax type,
        ITypeSymbol typeSymbol,
        ImmutableArray<ITypeSymbol> referencedTypes,
        ImmutableArray<IAliasSymbol> aliases
    ) {
        if (type.Modifiers.Any(SyntaxKind.FileKeyword)) {
            type = type.WithModifiers(
                SyntaxFactory.TokenList(type.Modifiers.Where(x => !x.IsKind(SyntaxKind.FileKeyword)))
            );
        }

        if (type.Modifiers.Any(SyntaxKind.PrivateKeyword)) {
            type = type.WithModifiers(
                SyntaxFactory.TokenList(type.Modifiers.Where(x => !x.IsKind(SyntaxKind.PrivateKeyword)))
            );
        }

        var usingDirectives = referencedTypes
            .Distinct(SymbolEqualityComparer.Default)
            .Where(x => x?.ContainingNamespace is not null && !SymbolEqualityComparer.Default.Equals(x.ContainingNamespace, typeSymbol.ContainingNamespace)) // Skip our own namespace
            .Select(t => t!.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
            .Where(x => !typeSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .StartsWith(x)) // Skip namespaces we're implicitly part of
            .Distinct()
            .Select(x => SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(x)))
            .ToList();

        foreach (var alias in aliases.Distinct(SymbolEqualityComparer.Default).OfType<IAliasSymbol>()) {
            usingDirectives.Add(
                SyntaxFactory.UsingDirective(
                    SyntaxFactory.NameEquals(alias.Name),
                    SyntaxFactory.ParseTypeName(alias.Target.Name) // Later we prolly want to spit out all types into their original namespace
                )
            );
        }

        var compilationUnit = SyntaxFactory.CompilationUnit()
            .WithUsings(SyntaxFactory.List(usingDirectives))
            .WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(type.WithoutTrivia()))
            .NormalizeWhitespace();

        var sourceCode = compilationUnit.ToFullString();
        return FragmentFactory.RawStringLiteral(sourceCode);
    }
}