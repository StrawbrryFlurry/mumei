using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Mumei.CodeGen.Qt.TwoStageBuilders.Components;
using Mumei.CodeGen.Qt.TwoStageBuilders.RoslynCodeProviders;

namespace Mumei.CodeGen.Qt;

[Generator]
internal sealed class SourceFileReferenceGenerator : IIncrementalGenerator {
    private const string SyntaxTreeReferenceCode =
        """
        // <auto-generated/>

        internal sealed class SourceCodeTypeRef : ITypeRef {
          public string TypeName { get; init; }
          public string SourceCode { get; init; }
          public global::System.Collections.Immutable.ImmutableArray<ITypeRef> References { get; init; }
        }

        internal sealed class AssemblyTypeRef : ITypeRef {
          public string AssemblyName { get; init; }
          public string FullyQualifiedName { get; init; }
        }

        [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
        internal static partial class SyntaxTreeReference {
          public static SourceCodeTypeRef Of<T>() {
              throw new global::System.InvalidOperationException("This method is intended to be intercepted at compile time and never invoked directly.");
          }
          
          public static SourceCodeTypeRef Of(global::System.Type t) {
            throw new global::System.InvalidOperationException("This method is intended to be intercepted at compile time and never invoked directly.");
          }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(static ctx => {
            ctx.AddEmbeddedAttributeDefinition();
            ctx.AddSource("SyntaxTreeReference.g.cs", SourceText.From(SyntaxTreeReferenceCode, Encoding.UTF8));
        });

        var p = context.CreateQtProvider(
            (node, ct) => {
                return SyntaxNodeFilter.IsInvocationOf(node, "Of", "SyntaxTreeReference");
            },
            static (syntaxContext, ct) => {
                return syntaxContext.Node;
            }
        );

        var o = p.IncrementalCompile(static (compilation, ctx, ct) => {
            var interceptor = compilation.DeclareClass("");

            var toEmit = compilation.NamespaceFromCompilation("Generated").WithMember(interceptor);
            compilation.TrackForEmission("Generated", toEmit);
        });

        context.RegisterCompilationOutput(o);
    }
}

file sealed class InterceptorClassDecl : SyntheticClassDefinition<InterceptorClassDecl> {
    public override void InternalBindCompilerOutputMembers(ISyntheticClassBuilder<InterceptorClassDecl> classBuilder, InterceptorClassDecl target) {
        throw new NotImplementedException();
    }
}

file sealed class InterceptorMethodDecl<TResult> : SyntheticInterceptorMethodDefinition<TResult> {
    public override void BindDynamicComponents() {
        base.BindDynamicComponents();
    }
    public override ISyntheticCodeBlock GenerateMethodBody() {
        throw new NotImplementedException();
    }
}