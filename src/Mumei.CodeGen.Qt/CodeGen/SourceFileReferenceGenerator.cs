using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Mumei.CodeGen.Qt.Qt;
using Mumei.CodeGen.Qt.TwoStageBuilders.Components;
using Mumei.CodeGen.Qt.TwoStageBuilders.RoslynCodeProviders;

namespace Mumei.CodeGen.Qt;

[Generator]
internal sealed class SourceFileReferenceGenerator : IIncrementalGenerator {
    private const string SyntaxTreeReferenceCode =
        """
        // <auto-generated/>

        internal sealed class SourceCodeTypeRef : ITypeRef {
          public string TypeName { get; init; }
          public string SourceCode { get; init; }
          public global::System.Collections.Immutable.ImmutableArray<ITypeRef> References { get; init; }
        }

        internal sealed class AssemblyTypeRef : ITypeRef {
          public string AssemblyName { get; init; }
          public string FullyQualifiedName { get; init; }
        }

        [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
        internal static partial class SyntaxTreeReference {
          public static SourceCodeTypeRef Of<T>() {
              throw new global::System.InvalidOperationException("This method is intended to be intercepted at compile time and never invoked directly.");
          }
          
          public static SourceCodeTypeRef Of(global::System.Type t) {
            throw new global::System.InvalidOperationException("This method is intended to be intercepted at compile time and never invoked directly.");
          }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(static ctx => {
            ctx.AddEmbeddedAttributeDefinition();
            ctx.AddSource("SyntaxTreeReference.g.cs", SourceText.From(SyntaxTreeReferenceCode, Encoding.UTF8));
        });

        var p = context.CreateQtProvider(
            (node, ct) => {
                return SyntaxNodeFilter.IsInvocationOf(node, "Of", "SyntaxTreeReference");
            },
            static (syntaxContext, ct) => {
                return (InvocationExpressionSyntax) syntaxContext.Node;
            }
        );

        var o = p.IncrementalCompile(static (compilation, ctx, ct) => {
            var interceptor = compilation.DeclareClass("SyntaxTreeReferenceInterceptor");

            interceptor.DeclareInterceptorMethod(
                interceptor.MakeUniqueName("Intercept_Of"),
                ctx
            );

            var toEmit = compilation.NamespaceFromCompilation("Generated").WithMember(interceptor);
            compilation.TrackForEmission("Generated", toEmit);
        });

        context.RegisterCompilationOutput(o);
    }
}

file sealed class InterceptorClassDecl : SyntheticClassDefinition<InterceptorClassDecl> {
    [Input]
    public InvocationExpressionSyntax InvocationToIntercept { get; set; } = null!;

    public override void Setup(ISyntheticClassBuilder<InterceptorClassDecl> classBuilder) {
        classBuilder.DeclareInterceptorMethod<InterceptorMethodDecl>(
            classBuilder.MakeUniqueName("Intercept_Of"),
            InvocationToIntercept,
            decl => decl.InterceptOf<CompileTimeUnknown>
        );
    }

    public override void InternalBindCompilerOutputMembers(ISyntheticClassBuilder<InterceptorClassDecl> classBuilder, InterceptorClassDecl target) { }
}

file sealed class InterceptorMethodDecl : SyntheticInterceptorMethodDefinition {
    public override void BindDynamicComponents(BindingContext ctx) { }

    public override ISyntheticCodeBlock GenerateMethodBody() {
        throw new NotImplementedException();
    }

    public TResult InterceptOf<TResult>() {
        throw new CompileTimeComponentUsedAtRuntimeException();
    }
}