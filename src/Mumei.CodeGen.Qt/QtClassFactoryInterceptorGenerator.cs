using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Mumei.CodeGen.Qt.Output;
using Mumei.CodeGen.Qt.Qt;
using Mumei.CodeGen.Qt.Roslyn;
using Mumei.Roslyn;
using Mumei.Roslyn.Common;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Mumei.CodeGen.Qt;

[Generator]
public sealed partial class QtClassFactoryInterceptorGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var dynamicSourceCodeProvider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node is InvocationExpressionSyntax {
                Expression: MemberAccessExpressionSyntax { Name.Identifier.Text: nameof(QtClass.AddDynamicTemplateInterceptMethod) or nameof(QtClassDynamicDeclarationExtensions.AddTemplateInterceptMethod) } memberExpression
            } invocation,
            (ctx, ct) => {
                if (ctx.SemanticModel.GetOperation(ctx.Node, ct) is not IInvocationOperation invocationOperation) {
                    return default;
                }

                return ((InvocationExpressionSyntax) ctx.Node, ctx.SemanticModel, invocationOperation);
            }
        ).Where(x => x != default);

        context.RegisterSourceOutput(
            dynamicSourceCodeProvider.Collect(),
            (ctx, o) => Execute(ctx, o)
        );
    }

    private void Execute(SourceProductionContext context, ImmutableArray<(InvocationExpressionSyntax Node, SemanticModel SemanticModel, IInvocationOperation invocationOperation)> code) {
        var result = new SyntaxWriter();
        result.WriteLine("// <auto-generated/>");
        result.WriteLine("#nullable enable");
        result.WriteLine(
            """
            #pragma warning disable
            namespace System.Runtime.CompilerServices {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file sealed class InterceptsLocationAttribute(int version, string data) : Attribute;
            }
            #pragma warning enable

            namespace Mumei.CodeGen.Qt.Generated {
            """
        );

        result.Indent();

        result.WriteLine("file static class __QtInterceptorImpl {");
        result.Indent();

        foreach (var (invocation, semanticModel, invocationOperation) in code) {
            if (invocationOperation.TargetMethod.Name == nameof(QtClass.AddDynamicTemplateInterceptMethod)) {
                BindDynamicTemplateInterceptMethod(result, invocation, semanticModel, invocationOperation, context);
            }

            if (invocationOperation.TargetMethod.Name == nameof(QtClassDynamicDeclarationExtensions.AddTemplateInterceptMethod)) {
                BindTemplateInterceptMethod(result, invocation, semanticModel, invocationOperation, context);
            }
        }

        result.Dedent();
        result.WriteLine("}");
        result.Dedent();
        result.WriteLine("}");

        context.AddSource("QtClassFactoryInterceptor.g.cs", result.ToSyntax());
    }


    private void BindDynamicTemplateInterceptMethod(
        SyntaxWriter result,
        InvocationExpressionSyntax invocation,
        SemanticModel semanticModel,
        IInvocationOperation invocationOperation,
        SourceProductionContext context
    ) {
        var args = invocation.ArgumentList.Arguments;

        if (args.Count == 3) {
            WriteInterceptorMethodWithState(result, invocation, semanticModel, context);
            return;
        }

        WriteBasicInterceptorMethod(
            result,
            invocation,
            semanticModel
        );
    }

    private void WriteBasicInterceptorMethod(
        SyntaxWriter writer,
        InvocationExpressionSyntax invocation,
        SemanticModel semanticModel
    ) {
        var proxyId = NextId;

        var methodDeclaration = invocation.ArgumentList.Arguments[1];

        var method = (IMethodSymbol) semanticModel.GetSymbolInfo(invocation).Symbol!;
        var v = new QtInterceptorMethodDeclarationVisitor(semanticModel).Visit(methodDeclaration.Expression);
        BlockSyntax body;
        if (v is ParenthesizedLambdaExpressionSyntax complex) {
            body = (BlockSyntax) complex.Body;
        } else {
            body = (BlockSyntax) ((SimpleLambdaExpressionSyntax) v).Body;
        }

        var sourceCodeSections = MakeDynamicallyBoundSourceCodeSections(body.Statements, out _);
        WriteCachedSourceCodeDeclaration(writer, proxyId, sourceCodeSections);

        var location = semanticModel.GetInterceptableLocation(invocation);
        writer.WriteLine(location!.GetInterceptsLocationAttributeSyntax());
        writer.WriteFormattedLine($"public static {typeof(QtMethod<CompileTimeUnknown>):g} Intercept__{proxyId}(");
        writer.Indent();
        writer.WriteFormattedLine($"in this {typeof(QtClass):g} @this,");
        writer.WriteFormattedLine($"{typeof(InvocationExpressionSyntax):g} invocationToProxy,");

        var templateMethodType = method.TypeParameters.IsEmpty
            ? QtType.ForRuntimeType<DeclareQtInterceptorVoidMethod>()
            : QtType.ConstructRuntimeGenericType(typeof(DeclareQtInterceptorMethod<>), QtType.ForRoslynType(method.TypeArguments[0]));

        writer.WriteFormattedLine(
            $"{templateMethodType:g} declaration"
        );

        writer.Dedent();
        writer.WriteLine(") {");
        writer.Indent();

        writer.WriteFormattedBlock(
            $$"""
              var sourceCode = new {{typeof(__DynamicallyBoundSourceCode):g}}() {
                  {{nameof(__DynamicallyBoundSourceCode.CodeTemplate)}} = CachedSourceCodeTemplate_Intercept_{{proxyId}},
              };

              return @this.{{nameof(QtClass.__BindDynamicTemplateInterceptMethod)}}(
                invocationToProxy,
                sourceCode
              );
              """
        );

        writer.Dedent();
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private void WriteInterceptorMethodWithState(
        SyntaxWriter writer,
        InvocationExpressionSyntax invocation,
        SemanticModel semanticModel,
        SourceProductionContext ctx
    ) {
        var proxyId = NextId;

        var methodDeclaration = invocation.ArgumentList.Arguments[2];

        var method = (IMethodSymbol) semanticModel.GetSymbolInfo(invocation).Symbol!;
        var v = new QtInterceptorMethodDeclarationVisitor(semanticModel).Visit(methodDeclaration.Expression);
        BlockSyntax body;
        if (v is ParenthesizedLambdaExpressionSyntax complex) {
            body = (BlockSyntax) complex.Body;
        } else {
            body = (BlockSyntax) ((SimpleLambdaExpressionSyntax) v).Body;
        }

        var sourceCodeSections = MakeDynamicallyBoundSourceCodeSections(body.Statements, out var boundKeys);

        var stateArg = invocation.ArgumentList.Arguments[1].Expression;
        var stateType = semanticModel.GetTypeInfo(stateArg);
        if (!stateType.Type?.IsAnonymousType ?? false) {
            ctx.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "MOOM1000",
                        "Invalid Template Reference Type",
                        "The template reference type must be an anonymous type.",
                        "Usage",
                        DiagnosticSeverity.Error,
                        true
                    ),
                    stateArg.GetLocation()
                )
            );
            return;
        }

        var instantiateTemplateReferenceBindersExpr = WriteAdditionalReferenceStateBinders(writer, stateArg, semanticModel, boundKeys, proxyId);

        WriteCachedSourceCodeDeclaration(writer, proxyId, sourceCodeSections);

        var location = semanticModel.GetInterceptableLocation(invocation);
        writer.WriteLine(location!.GetInterceptsLocationAttributeSyntax());
        writer.WriteFormattedLine($"public static {typeof(QtMethod<CompileTimeUnknown>):g} Intercept__{proxyId}<TTemplateReferences>(");
        writer.Indent();
        writer.WriteFormattedLine($"in this {typeof(QtClass):g} @this,");
        writer.WriteFormattedLine($"{typeof(InvocationExpressionSyntax):g} invocationToProxy,");

        var refsArgType = QtType.ForRoslynType(method.TypeArguments[0]);
        writer.WriteFormattedLine($"TTemplateReferences references,");

        var templateMethodType = method.TypeParameters.Length == 1
            ? QtType.ConstructRuntimeGenericType(
                typeof(DeclareQtInterceptorVoidMethodWithRefs<>),
                QtType.ForExpression(QtExpression.For("TTemplateReferences"))
            )
            : QtType.ConstructRuntimeGenericType(
                typeof(DeclareQtInterceptorMethodWithRefs<,>),
                refsArgType,
                QtType.ForRoslynType(method.TypeArguments[1])
            );

        writer.WriteFormattedLine(
            $"{templateMethodType:g} declaration"
        );

        writer.Dedent();
        writer.WriteLine(") {");
        writer.Indent();

        writer.WriteFormattedBlock(
            $$"""
              var sourceCode = new {{typeof(__DynamicallyBoundSourceCode):g}}() {
                  {{nameof(__DynamicallyBoundSourceCode.CodeTemplate)}} = CachedSourceCodeTemplate_Intercept_{{proxyId}},
              };

              var dynamicComponentBinders = {{instantiateTemplateReferenceBindersExpr}};
              return @this.{{nameof(QtClass.__BindDynamicTemplateInterceptMethod)}}(
                invocationToProxy,
                sourceCode,
                dynamicComponentBinders
              );
              """
        );

        writer.Dedent();
        writer.WriteLine("}");
        writer.WriteLine();
    }
    private static void WriteCachedSourceCodeDeclaration(SyntaxWriter writer, string proxyId, string[] sourceCodeSections) {
        writer.WriteFormattedLine($"private static readonly string[] CachedSourceCodeTemplate_Intercept_{proxyId} = [");
        var ind = writer.IndentLevel;
        writer.SetIndentLevel(0);
        for (var i = 0; i < sourceCodeSections.Length; i++) {
            if (i > 0) {
                writer.WriteLine(",");
            }

            writer.WriteLine(Strings.RawStringLiteral12);
            var sourceCodeSection = sourceCodeSections[i];
            writer.WriteLine(sourceCodeSection);
            writer.Write(Strings.RawStringLiteral12);
        }

        writer.SetIndentLevel(ind);
        writer.WriteLine();
        writer.WriteLine("];");
        writer.WriteLine();
    }

    private QtExpression WriteAdditionalReferenceStateBinders(
        SyntaxWriter writer,
        ExpressionSyntax stateObjectExpression,
        SemanticModel semanticModel,
        string[] bindingKeys,
        string proxyId
    ) {
        var stateType = semanticModel.GetTypeInfo(stateObjectExpression).Type!;
        var stateMemberProperties = stateType.GetMembers()
            .OfType<IPropertySymbol>()
            .ToDictionary(x => x.Name, x => x);

        var stateBindings = new HashSet<string>();
        foreach (var key in bindingKeys) {
            var keySpan = key.AsSpan();
            if (!__DynamicallyBoundSourceCode.IsDynamicSection(keySpan)) {
                continue;
            }

            keySpan = __DynamicallyBoundSourceCode.GetDynamicSectionKey(keySpan);
            if (!keySpan.StartsWith(DynamicQtComponentBinder.BindDynamicComponent)) {
                continue;
            }

            keySpan = keySpan[(DynamicQtComponentBinder.BindDynamicComponent.Length + 1)..]; // +1 to skip the ':'
            if (!keySpan.StartsWith("QtArgState")) {
                throw new NotSupportedException("Found invalid dynamic binding source: " + key);
            }

            var stateKey = keySpan[("QtArgState".Length + 1)..].ToString(); // +1 to skip the ':'
            stateBindings.Add(stateKey);
        }

        if (stateBindings.Count == 0) {
            return QtExpression.Null;
        }

        // Since the state provided to the interceptor should always be an anonymous type
        // we need to mimic that type here. By default, the runtime will layout the class
        // members in memory automatically, and since the same rules should also apply to us,
        // we should not have to order the members the same way as the compiler would. Generating
        // a property for each member will automatically generate a backing field for it, leaving us
        // with the same members as the anonymous type would have.
        // -- TODO: We don't really need to generate an implementation for each state, we could simply re-use
        // a generic implementation and type that accordingly.
        var stateAccessorClassName = $"QtArgStateAccessor__{proxyId}";
        writer.WriteFormattedLine($"private sealed class {stateAccessorClassName} {{");
        writer.Indent();
        foreach (var stateMemberProperty in stateMemberProperties) {
            var property = stateMemberProperty.Value;
            var propertyType = QtType.ForRoslynType(property.Type);
            writer.WriteLine($"public {propertyType:g} {property.Name} {{ get; }}");
        }

        writer.Dedent();
        writer.WriteLine("}");

        var stateBinders = ImmutableArray.CreateBuilder<QtExpression>(stateBindings.Count);
        var syntaxNodeType = semanticModel.Compilation.GetTypeByMetadataName(typeof(SyntaxNode).FullName!);
        foreach (var stateBinding in stateBindings) {
            if (!stateMemberProperties.TryGetValue(stateBinding, out var stateProperty)) {
                throw new InvalidOperationException("Could not find state property for key: " + stateBinding);
            }

            var syntaxNodeConversion = semanticModel.Compilation.ClassifyConversion(stateProperty.Type, syntaxNodeType!);
            var isSyntaxNode = syntaxNodeConversion.IsImplicit;
            if (isSyntaxNode) {
                var qtStateType = QtType.ForRoslynType(stateProperty.Type);
                var binderBaseType = QtType.ConstructRuntimeGenericType(typeof(QtDynamicSyntaxNodeBinderBase<>), qtStateType);
                var thisBinderClassName = $"QtArgStateBinder_{stateBinding}__{proxyId}";
                writer.WriteFormattedLine(
                    $"private sealed class {thisBinderClassName}({qtStateType:g} node) : {binderBaseType:g}(node) {{ }}");
                var binderKey = DynamicQtComponentBinder.CreateDynamicComponentBinderKey($"QtArgState:{stateBinding}");
                stateBinders.Add(
                    QtExpression.ForExpression(
                        $$"""

                          { "{{binderKey}}", new {{thisBinderClassName}}({{typeof(Unsafe):g}}.As<TTemplateReferences, {{stateAccessorClassName}}>(ref references).{{stateBinding}}) }
                          """
                    )
                );
            }
        }

        var stateBinderExprs = stateBinders.ToArray().AsMemory().RepresentAsSeparatedList(x => x);
        var createBinderExpression = QtExpression.ForExpression($"new {typeof(QtDynamicComponentBinderCollection):g}() {{ {stateBinderExprs} }}");
        return createBinderExpression;
    }

    private static string[] MakeDynamicallyBoundSourceCodeSections(
        SyntaxList<StatementSyntax> statements,
        out string[] boundKeys
    ) {
        ReadOnlySpan<char> code = statements.ToFullString();
        var source = CleanUpCapturedSourceCode(code).AsSpan();
        // We could prolly make the binding of syntax nodes / context objs to the source code fully compile-time as well
        // Since we know all arguments and references of "external" code at this point.
        var result = new ArrayBuilder<string>();
        var boundKeysBuilder = new ArrayBuilder<string>();
        while (true) {
            var markerIdx = __DynamicallyBoundSourceCode.FindDynamicSectionStart(source);
            if (markerIdx == -1) {
                result.Add(source.ToString());
                break;
            }

            result.Add(source[..markerIdx].ToString());
            source = source[markerIdx..];
            var endIdx = __DynamicallyBoundSourceCode.FindDynamicSectionEnd(source);
            Debug.Assert(endIdx != -1);
            var identifier = source[..endIdx].ToString();
            result.Add(identifier);
            boundKeysBuilder.Add(identifier);
            source = source[(endIdx + 1)..];
        }

        boundKeys = boundKeysBuilder.ToArrayAndFree();
        return result.ToArrayAndFree();
    }

    private static string CleanUpCapturedSourceCode(
        ReadOnlySpan<char> source
    ) {
        var whitespaceToSkip = DetermineAccidentalTriviaIndentCount(source);
        var result = new ValueSyntaxWriter(stackalloc char[ValueSyntaxWriter.StackBufferSize]);

        while (source.Length != 0) {
            var lineEnd = source.IndexOf("\n");
            lineEnd = lineEnd == -1 ? source.Length : lineEnd + 1; // Include the newline character in the line

            var line = source[..lineEnd];

            var whitespaceCount = 0;
            var maxWhiteSpaceToSkip = Math.Min(whitespaceToSkip, line.Length);
            for (var j = 0; j < maxWhiteSpaceToSkip; j++) {
                if (!char.IsWhiteSpace(line[j]) || line[j] == '\n' || line[j] == '\r') {
                    break;
                }

                whitespaceCount++;
            }

            var charsToRemove = Math.Min(whitespaceCount, whitespaceToSkip);

            result.Write(line[charsToRemove..]);
            source = source[lineEnd..];
        }

        return result.ToString();
    }

    private static int DetermineAccidentalTriviaIndentCount(in ReadOnlySpan<char> source) {
        var indentChars = 0;
        while (source[indentChars] is ' ' or '\t' && source[indentChars] != '\n' && indentChars < source.Length) {
            indentChars++;
        }

        return indentChars;
    }

    private sealed class QtInterceptorMethodDeclarationVisitor(
        SemanticModel sm
    ) : GloballyQualifyingSyntaxRewriter(sm) {
        private string? _ctxIdentifier;
        private string? _stateIdentifier;

        private const string _replaceStateExpressionWithAnnotationKind = "ReplaceStateExpressionWith";
        private const string _replaceContextExpressionWithAnnotationKind = "ReplaceContextExpressionWith";

        public override SyntaxNode? VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node) {
            if (_ctxIdentifier is not null) {
                return base.VisitSimpleLambdaExpression(node);
            }

            _ctxIdentifier = node.Parameter.Identifier.Text;
            return base.VisitSimpleLambdaExpression(node);
        }

        public override SyntaxNode? VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node) {
            if (_ctxIdentifier is not null) {
                return base.VisitParenthesizedLambdaExpression(node);
            }

            var isSimpleDynamicBinding = node.ParameterList.Parameters.Count == 1;
            if (isSimpleDynamicBinding) {
                _ctxIdentifier = node.ParameterList.Parameters[0].Identifier.Text;
                return base.VisitParenthesizedLambdaExpression(node);
            }

            var isDynamicBindingWithState = node.ParameterList.Parameters.Count == 2;
            if (isDynamicBindingWithState) {
                _ctxIdentifier = node.ParameterList.Parameters[0].Identifier.Text;
                _stateIdentifier = node.ParameterList.Parameters[1].Identifier.Text;
                return base.VisitParenthesizedLambdaExpression(node);
            }

            throw new InvalidOperationException(
                "Expected either a simple dynamic binding with one parameter or a dynamic binding with state with two parameters."
            );
        }

        public override SyntaxNode? VisitInvocationExpression(InvocationExpressionSyntax node) {
            Debug.Assert(_ctxIdentifier is not null);

            if (node.Expression is not MemberAccessExpressionSyntax memberAccess) {
                return base.VisitInvocationExpression(node);
            }

            if (
                memberAccess.Name is GenericNameSyntax {
                    TypeArgumentList.Arguments.Count: 1,
                    Identifier.Text: nameof(IQtThis.Is)
                }
            ) {
                // Ignore all Is<> calls
                // If we called Is<> on <This> we still want to visit the <This>
                // expression to write the this binding into this place.
                // TODO: Should we track what casts are performed here and validate
                // that the the target type is a valid conversion for <this> when
                // the resulting template is bound?
                return Visit(memberAccess.Expression);
            }

            // This would be a call on the ctx object e.g. ctx.Invoke(...)
            if (memberAccess.Expression is SimpleNameSyntax invokee) {
                if (invokee.Identifier.Text == _ctxIdentifier) {
                    return MakeMakerLiteralFor(memberAccess.Name.Identifier, node);
                }

                return base.VisitInvocationExpression(node);
            }

            // Since all state expressions are on the state object, invocations on the state object
            // will (almost) always be a nested member access e.g. state.someRef.Invoke();
            if (memberAccess.Expression is MemberAccessExpressionSyntax possibleStateAccess) {
                if (possibleStateAccess.Expression is not SimpleNameSyntax stateIdentifier) {
                    return base.VisitInvocationExpression(node);
                }

                if (stateIdentifier.Identifier.Text != _stateIdentifier) {
                    return base.VisitInvocationExpression(node);
                }

                // Not suuper sure if we can even do something here, since most state binding
                // is already handled by replacing the dynamic component binding - we'll see.
            }

            return base.VisitInvocationExpression(node);

        }

        public override SyntaxNode? VisitMemberAccessExpression(MemberAccessExpressionSyntax node) {
            if (node.Expression is not SimpleNameSyntax identifier) {
                return base.VisitMemberAccessExpression(node);
            }

            var identifierName = identifier.Identifier.Text;
            if (identifierName == _ctxIdentifier) {
                return MakeMakerLiteralFor(node.Name.Identifier, node);
            }

            if (identifierName == _stateIdentifier) {
                return MakeMakerLiteralCore(DynamicQtComponentBinder.CreateDynamicComponentBinderKey($"QtArgState:{node.Name.Identifier.Text}"), node);
            }

            return base.VisitMemberAccessExpression(node);
        }

        private IdentifierNameSyntax MakeMakerLiteralFor(SyntaxToken identifier, SyntaxNode sourceNode) {
            var binderKey = identifier.Text switch {
                nameof(QtDynamicInterceptorMethodCtx.This) => ProxyInvocationExpressionBindingContext.BindThis,
                nameof(QtDynamicInterceptorMethodCtx.Invoke) => ProxyInvocationExpressionBindingContext.BindInvocation,
                nameof(QtDynamicInterceptorMethodCtx.Method) => ProxyInvocationExpressionBindingContext.BindMethodInfo,
                nameof(QtDynamicInterceptorMethodCtx.InvocationArguments) => ProxyInvocationExpressionBindingContext.BindArguments,
                _ => throw new ArgumentOutOfRangeException()
            };

            return MakeMakerLiteralCore(binderKey, sourceNode);
        }

        private IdentifierNameSyntax MakeMakerLiteralCore(string markerExpr, SyntaxNode sourceNode) {
            return IdentifierName(__DynamicallyBoundSourceCode.MakeDynamicSection(markerExpr))
                .WithLeadingTrivia(sourceNode.GetLeadingTrivia())
                .WithTrailingTrivia(sourceNode.GetTrailingTrivia());
        }
    }

    private static string NextId => Guid.NewGuid().ToString("N");
}