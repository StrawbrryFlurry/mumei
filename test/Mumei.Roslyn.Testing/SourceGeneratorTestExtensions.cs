using FluentAssertions.Execution;
using FluentAssertions.Primitives;
using Microsoft.CodeAnalysis;
using Mumei.Roslyn.Testing.Template;

namespace Mumei.Roslyn.Testing;

public static class SourceGeneratorTestExtensions {
    public static SourceGeneratorTestAssertions Should(this SourceGeneratorTestResult testResult) {
        return new SourceGeneratorTestAssertions(testResult);
    }
}

public sealed class SourceGeneratorTestAssertions
    : ReferenceTypeAssertions<SourceGeneratorTestResult, SourceGeneratorTestAssertions> {
    protected override string Identifier { get; } = "SourceGeneratorTestResult";

    private readonly SourceGeneratorTestResult _testResult;

    public SourceGeneratorTestAssertions(SourceGeneratorTestResult testResult) : base(testResult) {
        _testResult = testResult;
    }

    public SourceGeneratorGeneratedFileAssertions HaveGeneratedFile(string filePath) {
        Subject.RunResult.Diagnostics.Should().BeEmpty();

        var generatedFile = Subject.RunResult.GeneratedTrees.SingleOrDefault(t => t.FilePath.EndsWith(filePath, StringComparison.InvariantCulture));
        Execute.Assertion
            .ForCondition(generatedFile is not null)
            .FailWith(
                "Expected file {0} to be generated, but only the following files exist {1}",
                filePath,
                string.Join(", ", Subject.RunResult.GeneratedTrees.Select(t => t.FilePath))
            );

        return new SourceGeneratorGeneratedFileAssertions(generatedFile!);
    }
}

public sealed class SourceGeneratorGeneratedFileAssertions
    : ReferenceTypeAssertions<SyntaxTree, SourceGeneratorGeneratedFileAssertions> {
    protected override string Identifier { get; } = "SourceGeneratorGeneratedFiles";

    public SourceGeneratorGeneratedFileAssertions(SyntaxTree tree) :
        base(tree) { }

    public AndConstraint<SourceGeneratorGeneratedFileAssertions> WithContent(
        string content,
        Action<SourceFileBuilder>? configure = null
    ) {
        var builder = new SourceFileBuilder(content);
        configure?.Invoke(builder);
        return AssertTextEqual(builder.ToString());
    }

    public AndConstraint<SourceGeneratorGeneratedFileAssertions> WithGeneratedContent(
        string content,
        Action<SourceFileBuilder>? configure = null
    ) {
        var builder = new SourceFileBuilder(content);
        builder.WithFileComment("<auto-generated />");
        configure?.Invoke(builder);
        return AssertTextEqual(builder.ToString());
    }

    public AndConstraint<SourceGeneratorGeneratedFileAssertions> WithGeneratedType(
        CompilationType content,
        Action<SourceFileBuilder>? configure = null
    ) {
        var builder = new SourceFileBuilder(content);
        builder.WithFileComment("<auto-generated />");
        configure?.Invoke(builder);
        return AssertTextEqual(builder.ToString());
    }

    private AndConstraint<SourceGeneratorGeneratedFileAssertions> AssertTextEqual(string expected) {
        var actual = Subject.ToString();
        var actualWithoutLineEndings = actual.Replace("\n", "").Replace("\r", "");
        var expectedWithoutLineEndings = expected.Replace("\n", "").Replace("\r", "");

        Execute.Assertion
            .ForCondition(actualWithoutLineEndings == expectedWithoutLineEndings)
            .FailWith("Expected content to be {0}{reason}, but found {1}", expected, actual);

        return new AndConstraint<SourceGeneratorGeneratedFileAssertions>(this);
    }
}